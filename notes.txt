http://neuralnetworksanddeeplearning.com/chap1.html
http://www.codingvision.net/ai/c-making-a-neural-network-that-plays-flappy-bird
https://stackoverflow.com/questions/10673585/start-thread-with-member-function
https://stackoverflow.com/questions/22657770/using-c-11-multithreading-on-non-static-member-function
https://stackoverflow.com/questions/17307275/what-is-the-printf-format-specifier-for-bool
https://stackoverflow.com/questions/7961792/device-constant-const
http://docs.nvidia.com/cuda/thrust/index.html
https://www.cse.iitb.ac.in/~aviral/reportFlappy.pdf










TODO FICZER dodanie numeru rundy przy aktualnym wyniku
TODO FICZER dodac spadanie
TODO ew. sily grawitacji
1. Main
  Tworzy obiekt klasy Rendering i odpala mainLoop
2. Rendering
    Konstruktor tworzy poczatkowy wyglad gry
    initAllegro inicjuje niezbedne czesci Allegro (tylko raz na poczatku)
    initGameElements Tworze glowne czesci layoutu (rowniez uruchamiane tylko raz)
    drawTrees i drawTree rysują aktulny stan drzewek na planszy, uzywane
    tylko gdy jest runda testowa
    drawInitialBoard rysuje poczatkowy uklad planszy
    createEventQueue tworzy kolejke zdarzen i przypisuje do niej elementy (tylko raz)
    startGame czeka na gracza, ktory ma wyrazic chec rozpoczecia gry
    DONE TODO init zlaczenie startGame i drawInitialBoard ma ruszac przez kazda turą testową
    WIP TODO mainLoop dwa mozliwe typy runda
      testowa : wyswietla plansze, zapuszcza petle while i czeka eventy
      rozpatruje tylko timery, ktore jesli przychodza to wylicza nowe pozycje drzew
      oraz mowi sieciom neuronowym ze maja wykonac ruch (jesli bird aktywny)
      treningowa : rusza metode computeHiddenRounds z bota oraz zawiesza watek glowny
      i byc moze puszcza drugi watek z informacja o obliczeniach

3. Logic
    logic ma liste drzew, wynik gry, liste ptaszkow ora bota
    Konstruktor inicjuje bota, tj. losuje randomowe sieci neuronowe dla
    treningowych ptaszkow
    DONE TODO droppedTooLow sprawdza czy ktorys ptak spadl za nisko, jesli tak to
    active w birdzie
    intersects sprawdza czy jeden ptak sie przecial z kolem
    DONE TODO collisionCheck sprawdza czy ktorys ptak sie wpierdolil w cos, ale
    trzeba poprawic, bo nie ma zwracac booli tylko przypisywac je do active birda
    getIBirdPosition zwraca aktualna pozycje wybranego birda
    getTreePosition zwraca pozycje wybranego drzewa
    getNumberOfTrees zwraca liczbe drzew
    DONE TODO update poprawia pozycje ptakow, sprawdzajac czy jest aktywny i czy siec
    ustawila ze ma sie podbic, moveUp na false
    DONE TODO moveUp ustawia ptakowi ze ma sie podbic, gdy siec tak orzekła
    getScore daje wynik
    createTree tworzy drzewko i wrzuca do listy drzew
    getTextForResult przygotowuje wiadomosc o aktualnym wyniku
    DONE TODO treeToRemove usuwa drzewo jesli trzeba (nie trzeba dla kazdego pttaka,
    wystarczy pierwszy aktywny)

4. Bot
    initBot ustawia randomowe sieci dla ptaszkow
    computeHiddenRounds odpala N rund treningu, a nastepnie dla 10 najlepszych
    sieci wykorzystuje

5. Train
    TODO training odpala 20 razy rundke cuda -> aktualizacja wag
    na cude przekazuje zaktualizowane wagi, musi stworzyc tablice jednowymiarowa
    wag, zeby sensownie poskladac wszystkie sieci
    TODO fitness_function wymaga przekazania drugiej zmiennej na cude, do ktorej
    zapiszemy wartosci funkcji fitness
    TODO crossover, wymieszanie 10 najlepszych w jeden wzorzec, byc moze na cudzie
    TODO mutation, zmutowanie wzorca na pozostale treningowe knypki
    TODO chooseTenBest posortowanie fitnesow
    TODO populationEvolution polaczenie crossover i mutation, byc moze zbedne

6. Train.cu
    TODO glownyKernel odpowiedzialny za symulacje rozgrywki, jedyne co dostaje,
    to wagi oraz miejsce na fitness (id chyba nie trzeba, jest niezmienne,
    ta tablica jest potrzebna dopiero przy sortowaniu). Tworzy drzewa, nastepnie
    jakos tworzy ptaka dla kazdego kernela i symuluje ruchy funkcjami z Logic,
    ktore trzeba tutaj zaklepac jako kernele albo wkleic na chama

7. NeuralNetwork
    randInitialNetworks wylosowane losowych wag, moze zmienic wartosci ukryte na 0
    TODO randWeight losowanie wagi, ulepszyc z uniform z cpp11
    TODO sigmoid policzenie tego jak ma wygladac nastepny ruch

8. Tree
    TODO losowanie wysokosci drzew, trzeba sprawdzic losowanie na CUDZie

9. Bird
    TODO float x, y; bool active, moveUp; sensowne ustawienie tych pol w kostruktorze
    TODO na cudzie bedzie gorzej, chyba ze bede mogl stworzyc tam strukturke


    /*
    For i = 9; i >= 0; i++
    Jezeli nie ma elementu znalezionego na tej pozycji lub ten element jest mniejszy
    To przesun w prawo i contynuuj
    Else wstaw na poprzedniej
    */

    float bestFitness[10];
    int idxBestFit[10];
    bool occupiedId[10];


    for(int i=0; i<10; i++) occupiedId[i] = false;
    for(int i=0; i<UNITY_IN_TRAINING; i++)
    {
        for(j=9; j>=0; j--)
        {
            if(!occupiedId[j] && j!=0) {
                continue;
            }
            else if(!occupiedId[j] && j==0){
                occupiedId[j] = true;
                bestFitness[j] = fitCoefficients[i];
                idxBestFit[j] = i;
            }
            else if(bestFitness[j] < fitCoefficients[i]){
              for(int k=9; k>j; k--) // pozycja j zostaje pusta
              {
                bestFitness[k] = bestFitness[k-1];
              }
            }
            else if()
        }
    }


1. collison dla wszystkich 10-ciu
2. spadanie dla wszystkich


create a function which renders menu
and a function which renders a bird with trees and so on (you should have one already)
and where you do the rendering in the main loop
just check what function you should use
whether you are still on the menu or in the game
similarly in the event handling code

http://fizyka.pisz.pl/strona/1.html
http://fizyka.pisz.pl/strona/4.html
http://fizyka.pisz.pl/strona/7.html

not bad… but i can see a few issues:
- a minor issue would be that you are calling in main several functions like initAllegro, initGame, createEventQueue
 and while it's good to have all this code separated nicely into couple of functions it's not good to expose them all
 for the user - the user now must remember to call them in this partucular order and most likely will forget -
 it'd be nice to add one public method in the class Game called just "init" which calls all these methods for
 us or even better - just a constructor! you see, RAII and so on…
- i see that "reallocAll" just destroys everything… shouldn't be that just a destructor?
- method "solve" doesn't solve anything :v it's just a main loop - name it differently
- I think that solve can be too long and could be splitted into smaller functions, for example a function for handling
 trees and rendering logic should be separated from calculating positions and so on

- these were minor issues but there is a big, most important issue: you should design your game code so that you could
reuse it for bots! bot's won't look on nice graphics and probably won't even render it so the game logic should be
completely separated from rendering… I propose such solution that you have separate class for game logic, it should
check for collisions, calculate new bird position and so on
and has following methods:
- getCurrentBirdPosition - it returns just position, bots can use it for the input and rendering for the bird rendering
- getTreesPosition - like before
- update(double time) - updates the game, bots can use it for evaluation, rendering can use it for rendering the next
frame
- moveUp - moves bird up, and again rendering'd call it when user clicks, bots use it when they decide to move up
- getScore - self explanatory
and within this class the game logic is hidden, and it just presents a simple interface which is easy to use for both
bots and rendering the game for the user


- z podbijaniem jest tak że ptak spada cały czas na dół ze stałą prędkością a ruch podbijający po prostu go podnosi w uproszczeniu
możesz się pobawić też w siły grawitacji :v
czyli ptak ma przyspieszenie i podbijanie zmienia chwilowo przyspieszenie mocno do góry, bo zadziałala siła podbicia, a cały czas działa siła grawitacji w dół i wtedy to bedzie bardziej płynne

8. http://flappybird.io/

TODO
11. sila grawitacji (linki na gorze)
23. wznoszenie sie do poprawki
24. poprawki wyzej

DONE
5. spadanie i podnoszenie sie do testow
5.  sprzatanie kodu
13. dodac wyswietlanie wyniku
16. zmiany odleglosci miedzy drzewami
17. gra startuje po clicku
18. zliczanie wyniku (po wspolrzednej X)
20. kolizje rect vs rect
21. sprawic zeby text nie znikal
22. porzadna funkcja
15. kolizje kolko prostokat
12. dobor bird.y (albo dol albo gora) (byc moze rozwiaze poprzez nowe kolizje)

https://yal.cc/rectangle-circle-intersection-test/

http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html

//al_show_native_message_box(display, "YOU LOST!", "TRY AGAIN!", "Bird wyrżnął o coś!", NULL, ALLEGRO_MESSAGEBOX_WARN);
