http://fizyka.pisz.pl/strona/1.html
http://fizyka.pisz.pl/strona/4.html
http://fizyka.pisz.pl/strona/7.html

not bad… but i can see a few issues:
- a minor issue would be that you are calling in main several functions like initAllegro, initGame, createEventQueue
 and while it's good to have all this code separated nicely into couple of functions it's not good to expose them all
  for the user - the user now must remember to call them in this partucular order and most likely will forget -
   it'd be nice to add one public method in the class Game called just "init" which calls all these methods for
    us or even better - just a constructor! you see, RAII and so on…
- i see that "reallocAll" just destroys everything… shouldn't be that just a destructor?
- method "solve" doesn't solve anything :v it's just a main loop - name it differently
- I think that solve can be too long and could be splitted into smaller functions, for example a function for handling
 trees and rendering logic should be separated from calculating positions and so on
- these were minor issues but there is a big, most important issue: you should design your game code so that you could
reuse it for bots! bot's won't look on nice graphics and probably won't even render it so the game logic should be
completely separated from rendering… I propose such solution that you have separate class for game logic, it should
check for collisions, calculate new bird position and so on
and has following methods:
- getCurrentBirdPosition - it returns just position, bots can use it for the input and rendering for the bird rendering
- getTreesPosition - like before
- update(double time) - updates the game, bots can use it for evaluation, rendering can use it for rendering the next
frame
- moveUp - moves bird up, and again rendering'd call it when user clicks, bots use it when they decide to move up
- getScore - self explanatory
and within this class the game logic is hidden, and it just presents a simple interface which is easy to use for both
bots and rendering the game for the user


- z podbijaniem jest tak że ptak spada cały czas na dół ze stałą prędkością a ruch podbijający po prostu go podnosi w uproszczeniu
możesz się pobawić też w siły grawitacji :v
czyli ptak ma przyspieszenie i podbijanie zmienia chwilowo przyspieszenie mocno do góry, bo zadziałala siła podbicia, a cały czas działa siła grawitacji w dół i wtedy to bedzie bardziej płynne

8. http://flappybird.io/

TODO
11. sila grawitacji (linki na gorze)
23. wznoszenie sie do poprawki
24. poprawki wyzej

DONE
5. spadanie i podnoszenie sie do testow
5.  sprzatanie kodu
13. dodac wyswietlanie wyniku
16. zmiany odleglosci miedzy drzewami
17. gra startuje po clicku
18. zliczanie wyniku (po wspolrzednej X)
20. kolizje rect vs rect
21. sprawic zeby text nie znikal
22. porzadna funkcja
15. kolizje kolko prostokat
12. dobor bird.y (albo dol albo gora) (byc moze rozwiaze poprzez nowe kolizje)

https://yal.cc/rectangle-circle-intersection-test/

http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html

//al_show_native_message_box(display, "YOU LOST!", "TRY AGAIN!", "Bird wyrżnął o coś!", NULL, ALLEGRO_MESSAGEBOX_WARN);
